{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 What is Decompose? \u00b6 Decompose is a Kotlin Multiplatform lifecycle-aware business logic components (aka BLoCs) with routing functionality and pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React, etc.) This project is inspired by Badoos RIBs fork of the Uber RIBs framework. Supported targets \u00b6 Android JVM iosX64, iosArm64 macosX64 tvosX64, tvosArm64 JavaScript Why Decompose? \u00b6 Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits: Better separation of concerns Pluggable platform-specific UI (Compose, SwiftUI, React, etc.) Business logic code is testable with pure multiplatform unit tets Proper dependency injection (DI) and inversion of control (IoC) via constructor Shared navigation logic Lifecycle-aware components Components in the back stack are not destroyed, they continue working in background without UI Components and UI state preservation (mostly useful in Android) Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#what-is-decompose","text":"Decompose is a Kotlin Multiplatform lifecycle-aware business logic components (aka BLoCs) with routing functionality and pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React, etc.) This project is inspired by Badoos RIBs fork of the Uber RIBs framework.","title":"What is Decompose?"},{"location":"#supported-targets","text":"Android JVM iosX64, iosArm64 macosX64 tvosX64, tvosArm64 JavaScript","title":"Supported targets"},{"location":"#why-decompose","text":"Decompose draws clear boundaries between UI and non-UI code, which gives the following benefits: Better separation of concerns Pluggable platform-specific UI (Compose, SwiftUI, React, etc.) Business logic code is testable with pure multiplatform unit tets Proper dependency injection (DI) and inversion of control (IoC) via constructor Shared navigation logic Lifecycle-aware components Components in the back stack are not destroyed, they continue working in background without UI Components and UI state preservation (mostly useful in Android) Instances retaining (aka ViewModels) over configuration changes (mostly useful in Android)","title":"Why Decompose?"},{"location":"contributing/","text":"Contributing \u00b6 Documentation \u00b6 All of the documentation is stored in the docs/ folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs , so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image . # download the image docker pull squidfunk/mkdocs-material # run the server locally docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Then add the new documentation markdown file into the appropriate folder inside docs/ and add it to the mkdocs.yml file in the project so that it can be navigated to. Put up a pull request for review.","title":"Contributing"},{"location":"contributing/#contributing","text":"","title":"Contributing"},{"location":"contributing/#documentation","text":"All of the documentation is stored in the docs/ folder of this repository and is all written in markdown. The documentation is generated with Material MkDocs , so if you want to see what the changes look like locally it is recommended to use Docker with the Material MkDocs docker image . # download the image docker pull squidfunk/mkdocs-material # run the server locally docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material Then add the new documentation markdown file into the appropriate folder inside docs/ and add it to the mkdocs.yml file in the project so that it can be navigated to. Put up a pull request for review.","title":"Documentation"},{"location":"getting-started/","text":"Setup \u00b6 Decompose is published to Maven Central Repository. Add Decompose dependency to your build.gradle and replace <version> with the latest version . Groovy implementation \"com.arkivanov.decompose:decompose:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:decompose:<version>\" ) Android View Extensions \u00b6 Add extensions for Android View to your Android build.gradle : Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" ) Jetpack Compose Extensions \u00b6 Add extensions for Jetpack Compose to your Android build.gradle : Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) Jetpack Compose Multiplatform Extensions \u00b6 Add extensions for JetBrains Compose to your Android/JVM/Multiplatform build.gradle : Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Installation"},{"location":"getting-started/#setup","text":"Decompose is published to Maven Central Repository. Add Decompose dependency to your build.gradle and replace <version> with the latest version . Groovy implementation \"com.arkivanov.decompose:decompose:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:decompose:<version>\" )","title":"Setup"},{"location":"getting-started/#android-view-extensions","text":"Add extensions for Android View to your Android build.gradle : Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Android View Extensions"},{"location":"getting-started/#jetpack-compose-extensions","text":"Add extensions for Jetpack Compose to your Android build.gradle : Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" )","title":"Jetpack Compose Extensions"},{"location":"getting-started/#jetpack-compose-multiplatform-extensions","text":"Add extensions for JetBrains Compose to your Android/JVM/Multiplatform build.gradle : Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Jetpack Compose Multiplatform Extensions"},{"location":"license/","text":"Apache License Version 2.0, January 2004 http://www.apache.org/licenses/ TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION Definitions. \"License\" shall mean the terms and conditions for use, reproduction, and distribution as defined by Sections 1 through 9 of this document. \"Licensor\" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License. \"Legal Entity\" shall mean the union of the acting entity and all other entities that control, are controlled by, or are under common control with that entity. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"You\" (or \"Your\") shall mean an individual or Legal Entity exercising permissions granted by this License. \"Source\" form shall mean the preferred form for making modifications, including but not limited to software source code, documentation source, and configuration files. \"Object\" form shall mean any form resulting from mechanical transformation or translation of a Source form, including but not limited to compiled object code, generated documentation, and conversions to other media types. \"Work\" shall mean the work of authorship, whether in Source or Object form, made available under the License, as indicated by a copyright notice that is included in or attached to the work (an example is provided in the Appendix below). \"Derivative Works\" shall mean any work, whether in Source or Object form, that is based on (or derived from) the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work and Derivative Works thereof. \"Contribution\" shall mean any work of authorship, including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner. For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to the Licensor or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \"Not a Contribution.\" \"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute the Work and such Derivative Works in Source or Object form. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium, with or without modifications, and in Source or Object form, provided that You meet the following conditions: (a) You must give any other recipients of the Work or Derivative Works a copy of this License; and (b) You must cause any modified files to carry prominent notices stating that You changed the files; and \u00a9 You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, trademark, and attribution notices from the Source form of the Work, excluding those notices that do not pertain to any part of the Derivative Works; and (d) If the Work includes a \"NOTICE\" text file as part of its distribution, then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file, excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source form or documentation, if provided along with the Derivative Works; or, within a display generated by the Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file are for informational purposes only and do not modify the License. You may add Your own attribution notices within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, provided that such additional attribution notices cannot be construed as modifying the License. You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise complies with the conditions stated in this License. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or product names of the Licensor, except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the Work (and each Contributor provides its Contributions) on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, special, incidental, or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such Contributor has been advised of the possibility of such damages. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other liability obligations and/or rights consistent with this License. However, in accepting such obligations, You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional liability. END OF TERMS AND CONDITIONS APPENDIX: How to apply the Apache License to your work. To apply the Apache License to your work, attach the following boilerplate notice, with the fields enclosed by brackets \"[]\" replaced with your own identifying information. (Don't include the brackets!) The text should be enclosed in the appropriate comment syntax for the file format. We also recommend that a file or class name and description of purpose be included on the same \"printed page\" as the copyright notice for easier identification within third-party archives. Copyright [yyyy] [name of copyright owner] Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"samples/","text":"There are two sample apps: Counter and Todo List . Sample Counter App \u00b6 This sample demonstrates the following features: Nested components Routing Reused components State preservation (using StateKeeper ) Retaining instances (using InstanceKeeper ) Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React) Content: shared - the module which includes the following components: Counter - this component just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So Counter continues counting while in the back stack, unless recreated. It uses the InstanceKeeper , so counting continues after configuration changes. CounterInnerContainer - this component contains the Counter and two Routers on the left and on the right side. Each Router displays its stack of Counters and two buttons for navigation. \"Next\" button pushes another Counter to the corresponding Router , \"Prev\" button pops the active Counter for the Router . CounterRootComponent - this component contains the Counter , the Router of CounterInnerContainer and a button pushing another CounterInnerContainer to the stack. System back button is used for backward navigation. Android sample app iOS sample app JavaScript sample app Counter Component Structure \u00b6 Sample Todo List App \u00b6 The sample todo list app demonstrates the following features: Multiplatform: Android, iOS and Desktop Shared JetBrains Compose UI for Android and Desktop apps SwiftUI for iOS app Nested components Shared routing with view state preservation Using Lifecycle Multi-module structure (one component per module) Inter-component communication (via Reaktive , just an example) MVI using MVIKotlin Data persistence using SQLDelight Please refer to the sample's readme for more information. Todo Source Code \u00b6 The Todo sample app can be found in the JetBrains Compose repository here . Sample Master-Detail App \u00b6 \u26a0 This sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described above. This sample demonstrates the following features: Advanced master-detail navigation with automatic single-pane/multi-pane layout Nested components Pluggable UI (Jetpack Compose for Android and Desktop, more to come) Content: shared - the multiplatform module which includes the following components: ArticleList - the list of the items ArticleDetails - the details of the selected item Root - the root component navigating between screens compose-ui - the module containing Compose UI for Android and Desktop targets Android sample app Desktop sample app Sample Greetings App \u00b6 Sample Greetings Repository Related articles \u00b6 Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation Fully cross-platform Kotlin applications (almost)","title":"Samples"},{"location":"samples/#sample-counter-app","text":"This sample demonstrates the following features: Nested components Routing Reused components State preservation (using StateKeeper ) Retaining instances (using InstanceKeeper ) Pluggable UI (Android Views, Jetpack Compose, SwiftUI, JS React) Content: shared - the module which includes the following components: Counter - this component just increments the counter every 250 ms. It starts counting once created and stops when destroyed. So Counter continues counting while in the back stack, unless recreated. It uses the InstanceKeeper , so counting continues after configuration changes. CounterInnerContainer - this component contains the Counter and two Routers on the left and on the right side. Each Router displays its stack of Counters and two buttons for navigation. \"Next\" button pushes another Counter to the corresponding Router , \"Prev\" button pops the active Counter for the Router . CounterRootComponent - this component contains the Counter , the Router of CounterInnerContainer and a button pushing another CounterInnerContainer to the stack. System back button is used for backward navigation. Android sample app iOS sample app JavaScript sample app","title":"Sample Counter App"},{"location":"samples/#counter-component-structure","text":"","title":"Counter Component Structure"},{"location":"samples/#sample-todo-list-app","text":"The sample todo list app demonstrates the following features: Multiplatform: Android, iOS and Desktop Shared JetBrains Compose UI for Android and Desktop apps SwiftUI for iOS app Nested components Shared routing with view state preservation Using Lifecycle Multi-module structure (one component per module) Inter-component communication (via Reaktive , just an example) MVI using MVIKotlin Data persistence using SQLDelight Please refer to the sample's readme for more information.","title":"Sample Todo List App"},{"location":"samples/#todo-source-code","text":"The Todo sample app can be found in the JetBrains Compose repository here .","title":"Todo Source Code"},{"location":"samples/#sample-master-detail-app","text":"\u26a0 This sample is for advanced single-pane/multi-pane navigation and layout, for generic master-detail navigation please refer to the Sample Todo List App described above. This sample demonstrates the following features: Advanced master-detail navigation with automatic single-pane/multi-pane layout Nested components Pluggable UI (Jetpack Compose for Android and Desktop, more to come) Content: shared - the multiplatform module which includes the following components: ArticleList - the list of the items ArticleDetails - the details of the selected item Root - the root component navigating between screens compose-ui - the module containing Compose UI for Android and Desktop targets Android sample app Desktop sample app","title":"Sample Master-Detail App"},{"location":"samples/#sample-greetings-app","text":"Sample Greetings Repository","title":"Sample Greetings App"},{"location":"samples/#related-articles","text":"Decompose \u2014 experiments with Kotlin Multiplatform lifecycle-aware components and navigation Fully cross-platform Kotlin applications (almost)","title":"Related articles"},{"location":"component/custom-component-context/","text":"Custom ComponentContext \u00b6 If one is needing ComponentContext to have extra functionality that is not already provided. It is possible to create a custom ComponentContext that could be decorated with the desired functionality of your choice. Create and implement custom ComponentContext \u00b6 For example, to create your own custom ComponentContext one must first create an interface that extends ComponentContext and then provide its implementation. interface AppComponentContext : ComponentContext { // Custom things here } class DefaultAppComponentContext ( componentContext : ComponentContext , // Additional dependencies here ) : AppComponentContext , ComponentContext by componentContext { // Custom things implementation here } How to create router with custom ComponentContext \u00b6 In order to pass this AppComponentContext to other components in an application from the Router , make an extension function on the AppComponentContext interface. This custom extension function will create the Router and provide child AppComponentContext . fun < C : Parcelable , T : Any > AppComponentContext . appRouter ( initialConfiguration : () -> C , initialBackStack : () -> List < C > = :: emptyList , configurationClass : KClass < out C > , key : String = \"DefaultRouter\" , handleBackButton : Boolean = false , childFactory : ( configuration : C , AppComponentContext ) -> T ): Router < C , T > = router ( initialConfiguration = initialConfiguration , initialBackStack = initialBackStack , configurationClass = configurationClass , key = key , handleBackButton = handleBackButton ) { configuration , componentContext -> childFactory ( configuration , DefaultAppComponentContext ( componentContext = componentContext ) ) } Finally, in your components you can create a new router that will utilize the new custom component context. class MyComponent ( componentContext : AppComponentContext ): AppComponentContext by componentContext { private val router = appRouter ( initialConfiguration = { Configuration . Home }, childFactory = { configuration , appComponentContext -> // return child components using the custom component context } ) }","title":"Custom ComponentContext"},{"location":"component/custom-component-context/#custom-componentcontext","text":"If one is needing ComponentContext to have extra functionality that is not already provided. It is possible to create a custom ComponentContext that could be decorated with the desired functionality of your choice.","title":"Custom ComponentContext"},{"location":"component/custom-component-context/#create-and-implement-custom-componentcontext","text":"For example, to create your own custom ComponentContext one must first create an interface that extends ComponentContext and then provide its implementation. interface AppComponentContext : ComponentContext { // Custom things here } class DefaultAppComponentContext ( componentContext : ComponentContext , // Additional dependencies here ) : AppComponentContext , ComponentContext by componentContext { // Custom things implementation here }","title":"Create and implement custom ComponentContext"},{"location":"component/custom-component-context/#how-to-create-router-with-custom-componentcontext","text":"In order to pass this AppComponentContext to other components in an application from the Router , make an extension function on the AppComponentContext interface. This custom extension function will create the Router and provide child AppComponentContext . fun < C : Parcelable , T : Any > AppComponentContext . appRouter ( initialConfiguration : () -> C , initialBackStack : () -> List < C > = :: emptyList , configurationClass : KClass < out C > , key : String = \"DefaultRouter\" , handleBackButton : Boolean = false , childFactory : ( configuration : C , AppComponentContext ) -> T ): Router < C , T > = router ( initialConfiguration = initialConfiguration , initialBackStack = initialBackStack , configurationClass = configurationClass , key = key , handleBackButton = handleBackButton ) { configuration , componentContext -> childFactory ( configuration , DefaultAppComponentContext ( componentContext = componentContext ) ) } Finally, in your components you can create a new router that will utilize the new custom component context. class MyComponent ( componentContext : AppComponentContext ): AppComponentContext by componentContext { private val router = appRouter ( initialConfiguration = { Configuration . Home }, childFactory = { configuration , appComponentContext -> // return child components using the custom component context } ) }","title":"How to create router with custom ComponentContext"},{"location":"component/instance-keeper/","text":"InstanceKeeper \u00b6 Retaining instances over configurations change \u00b6 Decompose provides the InstanceKeeper API, similar to AndroidX ViewModels: class Child1 ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val viewModel = instanceKeeper . getOrCreate ( :: ViewModel ) private class ViewModel : InstanceKeeper . Instance { override fun onDestroy () { // Clean-up } } }","title":"InstanceKeeper"},{"location":"component/instance-keeper/#instancekeeper","text":"","title":"InstanceKeeper"},{"location":"component/instance-keeper/#retaining-instances-over-configurations-change","text":"Decompose provides the InstanceKeeper API, similar to AndroidX ViewModels: class Child1 ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val viewModel = instanceKeeper . getOrCreate ( :: ViewModel ) private class ViewModel : InstanceKeeper . Instance { override fun onDestroy () { // Clean-up } } }","title":"Retaining instances over configurations change"},{"location":"component/overview/","text":"Component Overview \u00b6 Every component represents a piece of logic with lifecycle and optional pluggable UI. Examples \u00b6 Simplest Component Example \u00b6 Here is an example of simple Counter component: class Counter { private val _value = MutableValue ( State ()) val state : Value < State > = _value fun increment () { _value . reduce { it . copy ( count = it . count + 1 ) } } data class State ( val count : Int = 0 ) } Jetpack/JetBrains Compose UI Example \u00b6 @Composable fun CounterUi ( counter : Counter ) { val state by counter . state . asState () Column { Text ( text = state . count . toString ()) Button ( onClick = counter :: increment ) { Text ( \"Increment\" ) } } } If you are using only Jetpack/JetBrains Compose UI, then most likely you can use its State and MutableState directly, without intermediate Value / MutableValue from Decompose. SwiftUI Example \u00b6 struct CounterView : View { private let counter : Counter @ ObservedObject private var state : ObservableValue < CounterState > init ( _ counter : Counter ) { self . counter = counter self . state = ObservableValue ( counter . state ) } var body : some View { VStack ( spacing : 8 ) { Text ( self . state . value . text ) Button ( action : self . counter . increment , label : { Text ( \"Increment\" ) }) } } } ComponentContext \u00b6 Each component has an associated ComponentContext which implements the following interfaces: RouterFactory , so you can create nested Routers in your Componenets StateKeeperOwner , so you can preserve any state during configuration changes and/or process death InstanceKeeperOwner , so you can retain instances in your components (like with AndroidX ViewModels) LifecycleOwner , so each component has its own lifecycle BackPressedDispatcherOwner , so each component can handle back button events So if a component requires any of the above features, just pass the ComponentContext via the component's constructor. You can use the delegation pattern to add the ComponentContext to this scope: class Counter ( componentContext : ComponentContext ) : ComponentContext by componentContext { // The rest of the code } When instantiating a root component we have to create ComponentContext manually. There is DefaultComponentContext which is the default implementation class of the ComponentContext . There are also handy helper functions provided by Jetpack/JetBrains Compose extension modules. Child components \u00b6 Decompose provides ability to organize components into trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a sub-tree into another place (reusing), you only need to satisfy its top component's dependencies. There are two common ways to add a child component: Using the Router - prefer this option when a navigation between components is required. Please head to the Router documentation page for more information. Adding a component as a permanent child - prefer this option if the child component should exist as long as the parent component. Adding a permanent child component \u00b6 To create the ComponentContext for a permanent child component use ComponentContext.childContext(...) extension function: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val counter = Counter ( childContext ( key = \"Counter\" )) } \u26a0\ufe0f Never pass parent's ComponentContext to children, always use either the Router or the childContext(...) function.","title":"Overview"},{"location":"component/overview/#component-overview","text":"Every component represents a piece of logic with lifecycle and optional pluggable UI.","title":"Component Overview"},{"location":"component/overview/#examples","text":"","title":"Examples"},{"location":"component/overview/#simplest-component-example","text":"Here is an example of simple Counter component: class Counter { private val _value = MutableValue ( State ()) val state : Value < State > = _value fun increment () { _value . reduce { it . copy ( count = it . count + 1 ) } } data class State ( val count : Int = 0 ) }","title":"Simplest Component Example"},{"location":"component/overview/#jetpackjetbrains-compose-ui-example","text":"@Composable fun CounterUi ( counter : Counter ) { val state by counter . state . asState () Column { Text ( text = state . count . toString ()) Button ( onClick = counter :: increment ) { Text ( \"Increment\" ) } } } If you are using only Jetpack/JetBrains Compose UI, then most likely you can use its State and MutableState directly, without intermediate Value / MutableValue from Decompose.","title":"Jetpack/JetBrains Compose UI Example"},{"location":"component/overview/#swiftui-example","text":"struct CounterView : View { private let counter : Counter @ ObservedObject private var state : ObservableValue < CounterState > init ( _ counter : Counter ) { self . counter = counter self . state = ObservableValue ( counter . state ) } var body : some View { VStack ( spacing : 8 ) { Text ( self . state . value . text ) Button ( action : self . counter . increment , label : { Text ( \"Increment\" ) }) } } }","title":"SwiftUI Example"},{"location":"component/overview/#componentcontext","text":"Each component has an associated ComponentContext which implements the following interfaces: RouterFactory , so you can create nested Routers in your Componenets StateKeeperOwner , so you can preserve any state during configuration changes and/or process death InstanceKeeperOwner , so you can retain instances in your components (like with AndroidX ViewModels) LifecycleOwner , so each component has its own lifecycle BackPressedDispatcherOwner , so each component can handle back button events So if a component requires any of the above features, just pass the ComponentContext via the component's constructor. You can use the delegation pattern to add the ComponentContext to this scope: class Counter ( componentContext : ComponentContext ) : ComponentContext by componentContext { // The rest of the code } When instantiating a root component we have to create ComponentContext manually. There is DefaultComponentContext which is the default implementation class of the ComponentContext . There are also handy helper functions provided by Jetpack/JetBrains Compose extension modules.","title":"ComponentContext"},{"location":"component/overview/#child-components","text":"Decompose provides ability to organize components into trees, so each parent component is only aware of its immediate children. Hence the name of the library - \"Decompose\". You decompose your project by multiple independent reusable components. When adding a sub-tree into another place (reusing), you only need to satisfy its top component's dependencies. There are two common ways to add a child component: Using the Router - prefer this option when a navigation between components is required. Please head to the Router documentation page for more information. Adding a component as a permanent child - prefer this option if the child component should exist as long as the parent component.","title":"Child components"},{"location":"component/overview/#adding-a-permanent-child-component","text":"To create the ComponentContext for a permanent child component use ComponentContext.childContext(...) extension function: class SomeParent ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val counter = Counter ( childContext ( key = \"Counter\" )) } \u26a0\ufe0f Never pass parent's ComponentContext to children, always use either the Router or the childContext(...) function.","title":"Adding a permanent child component"},{"location":"component/state-keeper/","text":"StateKeeper \u00b6 Saving state over configurations change or process death \u00b6 Decompose provides the StateKeeper API for state preservation. Currently it relies on Parcelable interface. It can be used in multiplatform code but is only useful in Android. Here is a quick example: class Child1 ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var state = stateKeeper . consume < State > ( \"SAVED_STATE\" ) ?: State () init { stateKeeper . register ( \"SAVED_STATE\" ) { state } } @Parcelize private class State ( val someValue : Int = 0 ) : Parcelable }","title":"StateKeeper"},{"location":"component/state-keeper/#statekeeper","text":"","title":"StateKeeper"},{"location":"component/state-keeper/#saving-state-over-configurations-change-or-process-death","text":"Decompose provides the StateKeeper API for state preservation. Currently it relies on Parcelable interface. It can be used in multiplatform code but is only useful in Android. Here is a quick example: class Child1 ( componentContext : ComponentContext ) : ComponentContext by componentContext { private var state = stateKeeper . consume < State > ( \"SAVED_STATE\" ) ?: State () init { stateKeeper . register ( \"SAVED_STATE\" ) { state } } @Parcelize private class State ( val someValue : Int = 0 ) : Parcelable }","title":"Saving state over configurations change or process death"},{"location":"extensions/android/","text":"Extensions for Android views \u00b6 Setup \u00b6 Extensions for Android views are provided by the extensions-android module. Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" ) Content \u00b6 TBD","title":"Extensions for Android views"},{"location":"extensions/android/#extensions-for-android-views","text":"","title":"Extensions for Android views"},{"location":"extensions/android/#setup","text":"Extensions for Android views are provided by the extensions-android module. Groovy implementation \"com.arkivanov.decompose:extensions-android:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-android:<version>\" )","title":"Setup"},{"location":"extensions/android/#content","text":"TBD","title":"Content"},{"location":"extensions/compose/","text":"Extensions for Jetpack/JetBrains Compose \u00b6 Setup \u00b6 Since Jetpack and JetBrains Compose are published separately into different repositories, Decompose provides separate modules for each variant. Both modules provide similar functionality, but you need to choose the corresponding module depending on the used Compose variant. Setup extensions for Jetpack Compose \u00b6 Extensions for Jetpack Compose are provided by the extensions-compose-jetpack module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" ) Setup extensions for JetBrains Compose \u00b6 Extensions for JetBrains Compose are provided by the extensions-compose-jetbrains module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" ) Content \u00b6 As mentioned above both modules provide similar functionality. Most of the links in this document refer to the Jetpack module, however there usually a mirror in the JetBrains module. Converting Value to State \u00b6 To convert Decompose Value to Compose State use Value<T>.subscribeAsState(): State<T> extensions function: interface SomeComponent { val models : Value < Model > data class Model ( /*...*/ ) } @Composable fun SomeUi ( component : SomeComponent ) { val models : State < Model > by component . models . subscribeAsState () } Navigating between Composable components \u00b6 The Router provides the RouterState as Value<RouterState> which can be observed in a Composable component. This makes it possible to switch child Composable components following the Router . Both Compose extension modules provide the Children(...) function which has the following features: It listens for the RouterState changes and displays the corresponding child Composable component using the provided slot lambda. It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death. It animates between children if there is an animation spec provided. Switching between child components defined as a sealed class \u00b6 Prefer this variant if you also support non-Compose UI (like SwiftUI, React, etc): // Root interface RootComponent { val routerState : Value < RouterState <* , Child >> sealed class Child { data class Profile ( val component : ProfileComponent ) : Child () data class Settings ( val component : SettingsComponent ) : Child () } } @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { when ( val child = it . instance ) { is RootComponent . Child . Profile -> ProfileUi ( child . component ) is RootComponent . Child . Settings -> SettingsUi ( child . component ) } } } // Children interface ProfileComponent interface SettingsComponent @Composable fun ProfileUi ( profileComponent : ProfileComponent ) { // Omitted code } @Composable fun SettingsUi ( settingsComponent : SettingsComponent ) { // Omitted code } Switching between child components defined as a Composable function \u00b6 You may prefer this variant if you support only Compose UI: typealias Content = @Composable () -> Unit fun < T : Any > T . asContent ( content : @Composable ( T ) -> Unit ): Content = { content ( this ) } // Root interface RootComponent { val routerState : Value < RouterState <* , Content >> } @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { it . instance () } } // Children interface ProfileComponent interface SettingsComponent @Composable fun ProfileUi ( profileComponent : ProfileComponent ) { // Omitted code } @Composable fun SettingsUi ( settingsComponent : SettingsComponent ) { // Omitted code } You can read more about this approach in the following article: Fully cross-platform Kotlin applications (almost) . Animations \u00b6 Decompose provides the Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the animation argument to the Children function. Crossfade animation \u00b6 @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfade () ) { it . instance () } } Crossfade-Scale animation \u00b6 @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfadeScale () ) { it . instance () } } Slide animation \u00b6 @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = slide () ) { it . instance () } } Custom animations \u00b6 It is possible to define custom animations in two ways. Implementing the ChildAnimation manually: @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = someAnimation () ) { it . instance () } } fun < C : Any , T : Any > someAnimation (): ChildAnimation < C , T > = { routerState : RouterState < C , T > , childContent : ChildContent < C , T > -> // Render each frame here } Implementing the ChildAnimation using the childAnimation builder function: fun < C : Any , T : Any > someAnimation ( animationSpec : FiniteAnimationSpec < Float > = defaultChildAnimationSpec , ): ChildAnimation < C , T > = childAnimation ( animationSpec = animationSpec ) { key : Child . Created < C , T > , factor : Float , arrangement : PageArrangement , direction : PageAnimationDirection , content : @Composable ( Modifier ) -> Unit -> // Render each frame here } Please refer to the predefined animations for implementation examples.","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"extensions/compose/#extensions-for-jetpackjetbrains-compose","text":"","title":"Extensions for Jetpack/JetBrains Compose"},{"location":"extensions/compose/#setup","text":"Since Jetpack and JetBrains Compose are published separately into different repositories, Decompose provides separate modules for each variant. Both modules provide similar functionality, but you need to choose the corresponding module depending on the used Compose variant.","title":"Setup"},{"location":"extensions/compose/#setup-extensions-for-jetpack-compose","text":"Extensions for Jetpack Compose are provided by the extensions-compose-jetpack module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetpack:<version>\" )","title":"Setup extensions for Jetpack Compose"},{"location":"extensions/compose/#setup-extensions-for-jetbrains-compose","text":"Extensions for JetBrains Compose are provided by the extensions-compose-jetbrains module. Groovy implementation \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" Kotlin implementation ( \"com.arkivanov.decompose:extensions-compose-jetbrains:<version>\" )","title":"Setup extensions for JetBrains Compose"},{"location":"extensions/compose/#content","text":"As mentioned above both modules provide similar functionality. Most of the links in this document refer to the Jetpack module, however there usually a mirror in the JetBrains module.","title":"Content"},{"location":"extensions/compose/#converting-value-to-state","text":"To convert Decompose Value to Compose State use Value<T>.subscribeAsState(): State<T> extensions function: interface SomeComponent { val models : Value < Model > data class Model ( /*...*/ ) } @Composable fun SomeUi ( component : SomeComponent ) { val models : State < Model > by component . models . subscribeAsState () }","title":"Converting Value to State"},{"location":"extensions/compose/#navigating-between-composable-components","text":"The Router provides the RouterState as Value<RouterState> which can be observed in a Composable component. This makes it possible to switch child Composable components following the Router . Both Compose extension modules provide the Children(...) function which has the following features: It listens for the RouterState changes and displays the corresponding child Composable component using the provided slot lambda. It preserves components' UI state (e.g. scrolling position) in the back stack and over configuration changes and process death. It animates between children if there is an animation spec provided.","title":"Navigating between Composable components"},{"location":"extensions/compose/#switching-between-child-components-defined-as-a-sealed-class","text":"Prefer this variant if you also support non-Compose UI (like SwiftUI, React, etc): // Root interface RootComponent { val routerState : Value < RouterState <* , Child >> sealed class Child { data class Profile ( val component : ProfileComponent ) : Child () data class Settings ( val component : SettingsComponent ) : Child () } } @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { when ( val child = it . instance ) { is RootComponent . Child . Profile -> ProfileUi ( child . component ) is RootComponent . Child . Settings -> SettingsUi ( child . component ) } } } // Children interface ProfileComponent interface SettingsComponent @Composable fun ProfileUi ( profileComponent : ProfileComponent ) { // Omitted code } @Composable fun SettingsUi ( settingsComponent : SettingsComponent ) { // Omitted code }","title":"Switching between child components defined as a sealed class"},{"location":"extensions/compose/#switching-between-child-components-defined-as-a-composable-function","text":"You may prefer this variant if you support only Compose UI: typealias Content = @Composable () -> Unit fun < T : Any > T . asContent ( content : @Composable ( T ) -> Unit ): Content = { content ( this ) } // Root interface RootComponent { val routerState : Value < RouterState <* , Content >> } @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( rootComponent . routerState ) { it . instance () } } // Children interface ProfileComponent interface SettingsComponent @Composable fun ProfileUi ( profileComponent : ProfileComponent ) { // Omitted code } @Composable fun SettingsUi ( settingsComponent : SettingsComponent ) { // Omitted code } You can read more about this approach in the following article: Fully cross-platform Kotlin applications (almost) .","title":"Switching between child components defined as a Composable function"},{"location":"extensions/compose/#animations","text":"Decompose provides the Child Animation API for Compose, as well as some predefined animation specs. To enable child animations you need to pass the animation argument to the Children function.","title":"Animations"},{"location":"extensions/compose/#crossfade-animation","text":"@Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfade () ) { it . instance () } }","title":"Crossfade animation"},{"location":"extensions/compose/#crossfade-scale-animation","text":"@Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = crossfadeScale () ) { it . instance () } }","title":"Crossfade-Scale animation"},{"location":"extensions/compose/#slide-animation","text":"@Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = slide () ) { it . instance () } }","title":"Slide animation"},{"location":"extensions/compose/#custom-animations","text":"It is possible to define custom animations in two ways. Implementing the ChildAnimation manually: @Composable fun RootUi ( rootComponent : RootComponent ) { Children ( routerState = rootComponent . routerState , animation = someAnimation () ) { it . instance () } } fun < C : Any , T : Any > someAnimation (): ChildAnimation < C , T > = { routerState : RouterState < C , T > , childContent : ChildContent < C , T > -> // Render each frame here } Implementing the ChildAnimation using the childAnimation builder function: fun < C : Any , T : Any > someAnimation ( animationSpec : FiniteAnimationSpec < Float > = defaultChildAnimationSpec , ): ChildAnimation < C , T > = childAnimation ( animationSpec = animationSpec ) { key : Child . Created < C , T > , factor : Float , arrangement : PageArrangement , direction : PageAnimationDirection , content : @Composable ( Modifier ) -> Unit -> // Render each frame here } Please refer to the predefined animations for implementation examples.","title":"Custom animations"},{"location":"extensions/overview/","text":"Extensions Overview \u00b6 Decompose provides extension modules for various popular libraries and frameworks: Extensions for Jetpack/JetBrains Compose Extensions for Android views","title":"Overview"},{"location":"extensions/overview/#extensions-overview","text":"Decompose provides extension modules for various popular libraries and frameworks: Extensions for Jetpack/JetBrains Compose Extensions for Android views","title":"Extensions Overview"},{"location":"router/deeplinking/","text":"Deep linking \u00b6 Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components. Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android. Handling deep links \u00b6 Given the basic example from the Router overview page, we can easily handle deep links. Let's say we have a link like http://myitems.com?itemId=3 . When the user clicks on it, we want to open the details screen of the item with the provided id . When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the Root component. class RootComponent ( componentContext : ComponentContext , initialItemId : Long? = null ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = if ( initialItemId == null ) Config . List else Config . Details ( itemId = initialItemId ), initialBackStack = if ( initialItemId == null ) emptyList () else listOf ( Config . List ), handleBackButton = true , childFactory = :: createChild ) // Omitted code } Now, if the initialItemId is supplied, the first screen will be the ItemDetails component. The ItemList component will be in the back stack, so the user will be able to go back.","title":"Deep linking"},{"location":"router/deeplinking/#deep-linking","text":"Users following links on devices have one goal in mind: to get to the content they want to see. Decompose provides ability to override initial destinations and back stack. A typical approach is to parse deep links on the platform side and then pass the initial data to the root component and then down the tree to all the required components. Parsing deep links on the platform side is beyond this documentation. This information should be available in the platform's specific documentation. For example here is the related documentation for Android.","title":"Deep linking"},{"location":"router/deeplinking/#handling-deep-links","text":"Given the basic example from the Router overview page, we can easily handle deep links. Let's say we have a link like http://myitems.com?itemId=3 . When the user clicks on it, we want to open the details screen of the item with the provided id . When the user closes the details screen, they should be navigated back to the list screen. The idea is to pass parsed data from the deep link to a component responsible for navigation, in our case it is the Root component. class RootComponent ( componentContext : ComponentContext , initialItemId : Long? = null ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = if ( initialItemId == null ) Config . List else Config . Details ( itemId = initialItemId ), initialBackStack = if ( initialItemId == null ) emptyList () else listOf ( Config . List ), handleBackButton = true , childFactory = :: createChild ) // Omitted code } Now, if the initialItemId is supplied, the first screen will be the ItemDetails component. The ItemList component will be in the back stack, so the user will be able to go back.","title":"Handling deep links"},{"location":"router/overview/","text":"Router Overview \u00b6 The Router \u00b6 A key unit is the Router . It is responsible for managing components, just like FragmentManager . The Router supports back stack and so each component has its own Lifecycle . Each time a new component is pushed, the currently active component is stopped. When a component is popped from the back stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. Each component is created based on an associated Configuration . Configurations can be persisted via Android's saved state , thus allowing back stack restoration after configurations change or process death. When the back stack is restored, only currently active components are recreated. All others in the back stack remain destroyed, and recreated on demand when navigating back. Decompose defines both Parcelable interface and @Parcelize annotation in common code using expect/actual, which works well with Kotlin Multiplatform. You can read more about it here . The Router has a state consisting of a currently active component and a back stack, so it can be rendered as any other state. Child components can also have Routers (nested navigation), and each component can have more than one Router . Routing example \u00b6 Here is a very basic example of navigation between two child components: // ItemList component interface ItemList { // Omitted code fun onItemClicked ( id : Long ) } class ItemListComponent ( componentContext : ComponentContext , private val onItemSelected : ( id : Long ) -> Unit ) : ItemList , ComponentContext by componentContext { // Omitted code override fun onItemClicked ( id : Long ) { onItemSelected ( id ) } } // ItemDetails component interface ItemDetails { // Omitted code fun onCloseClicked () } class ItemDetailsComponent ( componentContext : ComponentContext , itemId : Long , private val onFinished : () -> Unit ) : ItemDetails , ComponentContext by componentContext { // Omitted code override fun onCloseClicked () { onFinished () } } // Root component interface Root { val routerState : Value < RouterState <* , Child >> sealed class Child { class List ( val component : ItemList ) : Child () class Details ( val component : ItemDetails ) : Child () } } class RootComponent ( componentContext : ComponentContext ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = Config . List , handleBackButton = true , childFactory = :: createChild ) override val routerState : Value < RouterState <* , Root . Child >> = router . state private fun createChild ( config : Config , componentContext : ComponentContext ): Root . Child = when ( config ) { is Config . List -> Root . Child . List ( itemList ( componentContext )) is Config . Details -> Root . Child . Details ( itemDetails ( componentContext , config )) } private fun itemList ( componentContext : ComponentContext ): ItemList = ItemListComponent ( componentContext = componentContext , onItemSelected = { router . push ( Config . Details ( itemId = it )) } ) private fun itemDetails ( componentContext : ComponentContext , config : Config . Details ): ItemDetails = ItemDetailsComponent ( componentContext = componentContext , itemId = config . itemId , onFinished = router :: pop ) private sealed class Config : Parcelable { @Parcelize object List : Config () @Parcelize data class Details ( val itemId : Long ) : Config () } } Multiple routers in a component \u00b6 When multiple Routers are required in one component, each such a Router must have a unique key associated. The keys are required to be unique only within the component, so it is ok for different components to have Routers with same keys. An exception will be thrown if multiple Routers with same key are detected in a component. class Root ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val topRouter = router < TopConfig , TopChild > ( key = \"TopRouter\" , // Omitted code ) private val bottomRouter = router < BottomConfig , BottomChild > ( key = \"BottomRouter\" , // Omitted code ) }","title":"Overview"},{"location":"router/overview/#router-overview","text":"","title":"Router Overview"},{"location":"router/overview/#the-router","text":"A key unit is the Router . It is responsible for managing components, just like FragmentManager . The Router supports back stack and so each component has its own Lifecycle . Each time a new component is pushed, the currently active component is stopped. When a component is popped from the back stack, the previous component is resumed. This allows business logic to run while the component is in the back stack. Each component is created based on an associated Configuration . Configurations can be persisted via Android's saved state , thus allowing back stack restoration after configurations change or process death. When the back stack is restored, only currently active components are recreated. All others in the back stack remain destroyed, and recreated on demand when navigating back. Decompose defines both Parcelable interface and @Parcelize annotation in common code using expect/actual, which works well with Kotlin Multiplatform. You can read more about it here . The Router has a state consisting of a currently active component and a back stack, so it can be rendered as any other state. Child components can also have Routers (nested navigation), and each component can have more than one Router .","title":"The Router"},{"location":"router/overview/#routing-example","text":"Here is a very basic example of navigation between two child components: // ItemList component interface ItemList { // Omitted code fun onItemClicked ( id : Long ) } class ItemListComponent ( componentContext : ComponentContext , private val onItemSelected : ( id : Long ) -> Unit ) : ItemList , ComponentContext by componentContext { // Omitted code override fun onItemClicked ( id : Long ) { onItemSelected ( id ) } } // ItemDetails component interface ItemDetails { // Omitted code fun onCloseClicked () } class ItemDetailsComponent ( componentContext : ComponentContext , itemId : Long , private val onFinished : () -> Unit ) : ItemDetails , ComponentContext by componentContext { // Omitted code override fun onCloseClicked () { onFinished () } } // Root component interface Root { val routerState : Value < RouterState <* , Child >> sealed class Child { class List ( val component : ItemList ) : Child () class Details ( val component : ItemDetails ) : Child () } } class RootComponent ( componentContext : ComponentContext ) : Root , ComponentContext by componentContext { private val router = router < Config , Root . Child > ( initialConfiguration = Config . List , handleBackButton = true , childFactory = :: createChild ) override val routerState : Value < RouterState <* , Root . Child >> = router . state private fun createChild ( config : Config , componentContext : ComponentContext ): Root . Child = when ( config ) { is Config . List -> Root . Child . List ( itemList ( componentContext )) is Config . Details -> Root . Child . Details ( itemDetails ( componentContext , config )) } private fun itemList ( componentContext : ComponentContext ): ItemList = ItemListComponent ( componentContext = componentContext , onItemSelected = { router . push ( Config . Details ( itemId = it )) } ) private fun itemDetails ( componentContext : ComponentContext , config : Config . Details ): ItemDetails = ItemDetailsComponent ( componentContext = componentContext , itemId = config . itemId , onFinished = router :: pop ) private sealed class Config : Parcelable { @Parcelize object List : Config () @Parcelize data class Details ( val itemId : Long ) : Config () } }","title":"Routing example"},{"location":"router/overview/#multiple-routers-in-a-component","text":"When multiple Routers are required in one component, each such a Router must have a unique key associated. The keys are required to be unique only within the component, so it is ok for different components to have Routers with same keys. An exception will be thrown if multiple Routers with same key are detected in a component. class Root ( componentContext : ComponentContext ) : ComponentContext by componentContext { private val topRouter = router < TopConfig , TopChild > ( key = \"TopRouter\" , // Omitted code ) private val bottomRouter = router < BottomConfig , BottomChild > ( key = \"BottomRouter\" , // Omitted code ) }","title":"Multiple routers in a component"}]}